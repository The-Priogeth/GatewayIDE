# üß© GatewayIDE Refactoring & Konsolidierung (Vor Agent-HQ-Integration)

---

## üóé Dokumentation & Strukturpflege

* **root.md** ‚Äì Inhalts- und Zustands√ºbersicht aktualisieren.
* **ARCHITECTURE.md** ‚Äì an aktuellen technischen Stand anpassen (Module, Threads, Zep, HMA).
* **README.md** ‚Äì als Einstiegspunkt: *Quickstart, Build, Run, Tabs/Navigation*.
* **services/GatewayAI/ai_service/** ‚Äì Verschachtelung reduzieren (max. eine Ebene).
* **GatewayIDE.App/ViewModels/MainWindowViewModel.cs** ‚Äì modularisieren (z. B. Unterordner `Tabs/` mit eigenen ViewModels).
* **/routes** ‚Äì Einzeldateien erg√§nzen, sobald Endpoint-Liste feststeht.

---

## üß† 1. Memory & Kontextverwaltung (Zep)

**Ziel:** Redundanzen beseitigen, zentrale Memory-Logik √ºber Zep oder lokales Modul.

**Subtasks:**

* Entscheidung:

  * Zep vollst√§ndig nutzen **oder** Fallback-Speicher entfernen.
* Wenn **Zep aktiv:**

  * API-Verwendung pr√ºfen (`graph.search`, `thread.add_messages`, `memory.context`).
  * Manuelle Kontextbl√∂cke entfernen.
  * Einheitliche Schnittstelle (`MemoryManager`) implementieren.
* Wenn **Zep deaktiviert:**

  * Lokales Memory kapseln.
  * Alle Zep-Spezifika entfernen.

---

## ü§ñ 2. Agentenstruktur & Selektoren

**Ziel:** Einheitliche Agenten-API, kein doppelter Code, klarer Dispatch.

**Subtasks:**

* Gemeinsames Interface: `Agent.respond(query)`.
* Personal- und GPT-Agenten vereinheitlichen.
* Einheitliches Antwortformat f√ºr Demos / Ich-Aggregation.
* Aggregation (Ich) und Speaker klar trennen oder bewusst integrieren.
* Selektoren abstrahieren (Mapping / Strategie-Pattern).
* Zielwahl modularisieren (`dispatchTarget()`-Funktion).

---

## üì¶ 3. Backend-Aufbau & Modularit√§t

**Ziel:** Klare Verantwortlichkeiten, saubere Imports, Wiederverwendbarkeit.

**Subtasks:**

* Agenten-Logik in `agents/` auslagern.
* Lebenszyklus zentralisieren (`init()`, `start()`, `reset()`).
* Zust√§nde kapseln (keine globalen Maps).
* Memory-Handling in eigenem Modul (`memory/`).
* Einheitliche Speicherstruktur (Queue, DB etc.).
* Wiederholte Formatierungen vermeiden.
* HMA-Kommunikation extrahieren: `HMAClient(init, send, fetch, retry)`.
* Tokens / Endpoints zentral konfigurieren.
* Zentrales Konfigurationssystem: `.env`, `config.json` oder `settings.yaml`.

---

## üöÄ 4. Bootstrap & Startlogik

**Ziel:** Klare Startsequenz, kein ‚Äûtoter‚Äú Code.

**Subtasks:**

* `bootstrap()` in Phasen gliedern:

  * `loadConfig()`, `connectHMA()`, `initAgents()`, `initMemory()`.
* Async-Abl√§ufe konsistent verketten (await / Promise / Event).
* Alte Startcodes & Tests entfernen.
* Startprozess dokumentieren (README oder Docstring).

---

## üí¨ 5. Chat-Routing & Nachrichtenfluss

**Ziel:** √úbersichtliche Struktur statt verschachtelter Bedingungen.

**Subtasks:**

* `ChatRouter` modularisieren (Handler pro Nachrichtentyp).
* Dispatch-Table einsetzen: `handlers[message.type]()`.
* Logging & Fehlerhandling zentralisieren (Middleware / Wrapper).
* Kommunikation nur √ºber Schnittstellen (keine Direktmanipulation am Memory).

---

## üì° 6. GRPC vs REST ‚Äì Evaluationsphase

**Ziel:** Technische Entscheidung vorbereiten, nicht voreilig treffen.

**Subtasks:**

* Entscheidungsmatrix: Vorteile / Nachteile in deinem Szenario.
* Nur aktivieren bei geplanter Diensttrennung oder Streaming.
* Optional: gRPC-Stub f√ºr internes Agentenprotokoll vorbereiten.

---

## üßπ 7. Cleanup & Vereinheitlichung

**Ziel:** Lesbarkeit, Wartbarkeit, Zukunftssicherheit.

**Subtasks:**

* Alte Tests & Funktionen l√∂schen.
* Doppelte Logik zusammenf√ºhren (DRY-Prinzip).
* Linting/Formatierung einf√ºhren: *black, isort, flake8, prettier.*
* Basis-Unit-Tests: Agent / Memory / HMA-Kommunikation.

---

## ‚öôÔ∏è Redundanz- und Konsolidierungsnotizen

| Thema                                                   | Status                 | N√§chster Schritt                                                                                                         |
| :------------------------------------------------------ | :--------------------- | :----------------------------------------------------------------------------------------------------------------------- |
| **Memory-Schicht (Fassade vs zep_autogen)**             | Teilweise gel√∂st       | `zep_autogen` als Kompatibilit√§ts-Layer markieren, intern auf `ZepMemory` durchreichen (Deprecation-Header, Re-exports). |
| **Routing / Thread-Mapping**                            | Offen                  | Eine Quelle: Backend liefert Mapping via `/meta`-Endpoint oder Konstanten; UI liest nur.                                 |
| **gRPC vs REST/WS**                                     | Offen                  | gRPC als Dev/Test-Double labeln; im Prod-Build deaktivieren.                                                             |
| **Prozessausf√ºhrung (DockerService vs ProcessManager)** | Offen                  | `ProcessManager` nur behalten, falls Non-Docker-Tools ben√∂tigt.                                                          |
| **Kontextaufbau**                                       | Weitgehend gekl√§rt     | Utility `context_builder.py` einf√ºhren; `zep_autogen` darauf umleiten.                                                   |
| **Logging / Telemetry**                                 | Offen                  | Zentrales Korrelation-Schema (`corr_id`, `thread`, `role`, `route`) in `messaging`.                                      |
| **Build-/Runtime-Pfad (CMD vs Compose)**                | Offen                  | Prod: Dockerfile-CMD = `backend.main:app`; Dev: Compose-Override dokumentieren.                                          |
| **Konfiguration (.env vs Hardcode)**                    | Offen                  | Endpoints ausschlie√ülich aus Settings/ENV lesen.                                                                         |
| **Zep-Graph-Operationen**                               | Offen                  | `zep_autogen/graph` auf `ZepGraphAdmin` durchrouten.                                                                     |
| **Thread-/User-IDs**                                    | Teilweise konsolidiert | ‚ÄûSingle Source‚Äú = Bootstrap; UI nur Anzeige.                                                                             |
| **gRPC-Protobuf (Client + Server)**                     | Offen                  | Proto an einem Ort pflegen; Server ‚Üí `tests/`.                                                                           |
| **UI-Layoutsteuerung**                                  | Offen                  | Konstanten / Converter zentralisieren (`HalfConverter`).                                                                 |
| **Dev-Container-Lifecycle**                             | Offen                  | Build-Script nur f√ºr Headless-Builds; UI steuert Laufzeit.                                                               |
| **Heuristik / Findings**                                | Offen                  | Eine Entscheidungsstelle (HMA-Pfad).                                                                                     |
| **uv.lock**                                             | Offen                  | Lock neu erzeugen, Plattform-Eintr√§ge pr√ºfen.                                                                            |

